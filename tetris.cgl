my score[0]; # awkward hack to make the display look nicer
my preview[4];
my board[23];
my input;

my randval;
my rand = 1;
my shifted;

my x[4];  # current piece location 
my y[4];
my xt[4]; # transposed piece location
my yt[4];
my px[4]; # preview piece location
my py[4];

my collision;
my piecescore;

my i;
my j;
my k;

# new game
score[0] = 65535;
i = 0;
do clear preview {
  preview[i] = 63519;
  i++;
} while (i < 4);
preview[4] = 65535;
i = 0;
do clear board {
  board[i] = 57351;
  i++;
} while (i < 22);
board[22] = 65535;

call newpreview();
call previewdrop();

score = 0;

do play game {
  call newpreview();
  do single piece {
    call updatepos();
    call printfallingpiece();
    input = display;
    display = 0;
    if (input == 1) rotate counterclockwise {
      xt[0] = y[1] - y[0];
      xt[0] += x[1];
      yt[0] = x[0] - x[1];
      yt[0] += y[1];
      xt[1] = x[1];
      yt[1] = y[1];
      xt[2] = y[1] - y[2];
      xt[2] += x[1];
      yt[2] = x[2] - x[1];
      yt[2] += y[1];
      xt[3] = y[1] - y[3];
      xt[3] += x[1];
      yt[3] = x[3] - x[1];
      yt[3] += y[1];
    }
    if (input == 2) move left {
      xt[0] = x[0] + 1;
      xt[1] = x[1] + 1;
      xt[2] = x[2] + 1;
      xt[3] = x[3] + 1;
    }
    if (input == 4) soft drop {
      yt[0] = y[0] + 1;
      yt[1] = y[1] + 1;
      yt[2] = y[2] + 1;
      yt[3] = y[3] + 1;
    }
    if (input == 8) move right {
      xt[0] = x[0] - 1;
      xt[1] = x[1] - 1;
      xt[2] = x[2] - 1;
      xt[3] = x[3] - 1;
    }
    if (input == 16) rotate clockwise {
      xt[0] = y[0] - y[1];
      xt[0] += x[1];
      yt[0] = x[1] - x[0];
      yt[0] += y[1];
      xt[1] = x[1];
      yt[1] = y[1];
      xt[2] = y[2] - y[1];
      xt[2] += x[1];
      yt[2] = x[1] - x[2];
      yt[2] += y[1];
      xt[3] = y[3] - y[1];
      xt[3] += x[1];
      yt[3] = x[1] - x[3];
      yt[3] += y[1];
    }
    rand ^= input; # inject randomness
    if (rand == 0) { # prevent prng bug
      rand = input;
    }
  
    call unprintfallingpiece();
    call testcollision();
    if (collision == 0) valid move {
      call updatepos();
      call printfallingpiece();
    } else invalid move {
      call printfallingpiece();
      xt[0] = x[0];
      yt[0] = y[0];
      xt[1] = x[1];
      yt[1] = y[1];
      xt[2] = x[2];
      yt[2] = y[2];
      xt[3] = x[3];
      yt[3] = y[3];
    }
    yt[0] = y[0] + 1;
    yt[1] = y[1] + 1;
    yt[2] = y[2] + 1;
    yt[3] = y[3] + 1;
    call unprintfallingpiece();
    call testcollision();
  } while (collision < 1);
  call printfallingpiece();
  
  piecescore = 1;
  i = 21;
  do check for clears {
    if (board[i] == -1) clear row {
      j = i;
      i++;
      piecescore <<= 1;
      do gravity {
        k = j - 1;
        board[j] = board[k];
        j--;
      } while (j > 0);
      board[0] = 57351;
    }
    i--;
  } while (i > 0);
  piecescore >>>= 1;
  score += piecescore;
  
  call previewdrop();
  call testcollision();
} while (collision < 1);

sub newpreview() {
  do prng {
    shifted = rand << 1;
    rand ^= shifted;
    shifted = rand >>> 5;
    rand ^= shifted;
    shifted = rand << 2;
    rand ^= shifted;
    randval = rand & 7;
  } while (randval < 1);
  if (randval == 1) Z tetromino {
    px[0] = 6;
    px[1] = 7;
    px[2] = 7;
    px[3] = 8;
    py[0] = 2;
    py[1] = 2;
    py[2] = 1;
    py[3] = 1;
  }
  if (randval == 2) S tetromino {
    px[0] = 6;
    px[1] = 7;
    px[2] = 7;
    px[3] = 8;
    py[0] = 1;
    py[1] = 2;
    py[2] = 1;
    py[3] = 2;
  }
  if (randval == 3) O tetromino{
    px[0] = 7;
    px[1] = 8;
    px[2] = 7;
    px[3] = 8;
    py[0] = 1;
    py[1] = 1;
    py[2] = 2;
    py[3] = 2;
  }
  if (randval == 4) I tetromino {
    px[0] = 6;
    px[1] = 7;
    px[2] = 8;
    px[3] = 9;
    py[0] = 1;
    py[1] = 1;
    py[2] = 1;
    py[3] = 1;
  }
  if (randval == 5) L tetromino {
    px[0] = 6;
    px[1] = 7;
    px[2] = 8;
    px[3] = 8;
    py[0] = 1;
    py[1] = 1;
    py[2] = 1;
    py[3] = 2;
  }
  if (randval == 6) J tetromino {
    px[0] = 8;
    px[1] = 7;
    px[2] = 6;
    px[3] = 6;
    py[0] = 1;
    py[1] = 1;
    py[2] = 1;
    py[3] = 2;
  }
  if (randval == 7) T tetromino {
    px[0] = 6;
    px[1] = 7;
    px[2] = 7;
    px[3] = 8;
    py[0] = 1;
    py[1] = 1;
    py[2] = 2;
    py[3] = 1;
  }
  shifted = 1 << px[0];
  preview[py[0]] |= shifted;
  shifted = 1 << px[1];
  preview[py[1]] |= shifted;
  shifted = 1 << px[2];
  preview[py[2]] |= shifted;
  shifted = 1 << px[3];
  preview[py[3]] |= shifted;
}

sub previewdrop() {
  xt[0] = px[0];
  xt[1] = px[1];
  xt[2] = px[2];
  xt[3] = px[3];
  yt[0] = py[0];
  yt[1] = py[1];
  yt[2] = py[2];
  yt[3] = py[3];
  preview[1] = 63519;
  preview[2] = 63519;
}

sub printfallingpiece() {
  shifted = 1 << x[0];
  board[y[0]] |= shifted;
  shifted = 1 << x[1];
  board[y[1]] |= shifted;
  shifted = 1 << x[2];
  board[y[2]] |= shifted;
  shifted = 1 << x[3];
  board[y[3]] |= shifted;
}

sub unprintfallingpiece() {
  shifted = 1 << x[0];
  board[y[0]] &!= shifted;
  shifted = 1 << x[1];
  board[y[1]] &!= shifted;
  shifted = 1 << x[2];
  board[y[2]] &!= shifted;
  shifted = 1 << x[3];
  board[y[3]] &!= shifted;
}

sub updatepos() {
  x[0] = xt[0];
  y[0] = yt[0];
  x[1] = xt[1];
  y[1] = yt[1];
  x[2] = xt[2];
  y[2] = yt[2];
  x[3] = xt[3];
  y[3] = yt[3];
}

sub testcollision() {
  collision = board[yt[0]] >>> xt[0];
  shifted = board[yt[1]] >>> xt[1];
  collision |= shifted;
  shifted = board[yt[2]] >>> xt[2];
  collision |= shifted;
  shifted = board[yt[3]] >>> xt[3];
  collision |= shifted;
  collision &= 1;
}
